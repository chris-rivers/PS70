<!DOCTYPE html>
<html lang="en">

<title>PS70: Intro to Digital Fabrication </title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/css/bootstrap.min.css" rel="stylesheet">
<link href="../style.css" rel="stylesheet">


<nav class="navbar navbar-expand-sm navbar-dark" style="background-color: #130F1D; color: #EEE7E8;">
  <div style="align-items: center; justify-content: center;" class="container-fluid">
    <div class="flexrow">
      <h2 class="nav-title">PS70 // Intro to Digital Fabrication // F23</h2>
    </div>
    <div class="navbar-nav">
      <h4><a class="nav-link" href="../index.html">Home</a></h4>
      <h4><a class="nav-link" href="../about.html">About</a></h4>
    </div>
  </div>
</nav>

<body>
<xmp style="display:none;">
<div class="textcontainer">
<p class="margin">   </p>

<h3>Week 1: Final Project Proposal</h3>

<p class="margin">   </p>
<div class="flexrow">
  <a id="btn" href="wk7.zip" download>Download my files from this week!
  </a>
</div>
<p class="margin">   </p>

<h4>Assignment: Minimum Viable Product for Final Project</h4>

My final project is going to be a "drawing machine" of sorts, that scans objects in 3D and translates them to 2D coordinates it can draw. Particularly I'm interested in translating things to curvilinear coordinates (such that they appear to be projected on a lens or sphere).

The way the machine will work is by having an arm with an ultrasonic sensor sweep across the x and y planes recording it's position at each step while the sensor itself records the z direction in front of it. I decided in class that the movement along the x and y axes ought to be controlled using stepper motors, and I'd already played around enough with the ultrasonic sensor to have a decent idea of how to use it. 

The main thing I was concerned about was writing code that would allow the machine to know where the sensor was at any given point and to (after completeing a full scan from an inital (0,0) to (Max_x, Max_y)) return three arrays with x, y, and z coordinates throughout the scan. Over the course of the spring break I came up with some code that would hopefully do just that. 

A really nifty thing I stumbled upon in the lab was a broken 3D printer which I happily claimed the scraps of for my project. The things I salvaged from it were the stepper motors (which there were like 4 of) and their appropriate wiring (which would have been a real pain to strip and keep track of on my own), and the tracks, which I didn't end up using for my mvp, but I do intend to incorporate or at least use the design of for the finished project. (The 3D printer is already a multi-axis stepper motor system, so reusing as much of it as possible is a huge W). 

<pre><code style="background-color: #2d2b33;">
 #include <AccelStepper.h>

// Define the number of steps per revolution for each motor
#define STEPS_PER_REV 200

// Define the pins connected to the stepper motor drivers
#define X_STEP_PIN 13
#define X_DIR_PIN 12
#define Y_STEP_PIN 4
#define Y_DIR_PIN 5

// Define the distance to move along each axis for one sweep
#define X_SWEEP_DISTANCE 200
#define Y_SWEEP_DISTANCE 1  

// Define initial position
#define INITIAL_X_POS 0
#define INITIAL_Y_POS 0

// Define ultrasonic sensor pins
#define TRIGGER_PIN 6
#define ECHO_PIN 7

// Initialize the stepper motors
AccelStepper stepperX(AccelStepper::DRIVER, X_STEP_PIN, X_DIR_PIN);
AccelStepper stepperY(AccelStepper::DRIVER, Y_STEP_PIN, Y_DIR_PIN);

// Initialize position variables
int xPos = INITIAL_X_POS;
int yPos = INITIAL_Y_POS;


void setup() {
  // Set up the ultrasonic sensor pins
  pinMode(TRIGGER_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);
  
  Serial.begin(9600);

  // Set the maximum speed and acceleration for each motor
  stepperX.setMaxSpeed(100); // Adjust as needed
  stepperX.setAcceleration(100); // Adjust as needed
  stepperY.setMaxSpeed(100); // Adjust as needed
  stepperY.setAcceleration(100); // Adjust as needed
}

void loop() {

  // Sweep along the x-axis
  stepperX.moveTo(X_SWEEP_DISTANCE);
  while (stepperX.distanceToGo() != 0) {
    stepperX.run();
    xPos++;
   

  // Move down a small increment in the y direction
  stepperY.move(Y_SWEEP_DISTANCE);
  stepperY.runToPosition();
  yPos++;

  // Sweep along the x-axis in the opposite direction
  stepperX.moveTo(0);
  while (stepperX.distanceToGo() != 0) {
    stepperX.run();
    xPos--;
   
  }

  // Move down another increment in the y direction
  stepperY.move(Y_SWEEP_DISTANCE);
  stepperY.runToPosition();
  yPos++;


  // Repeat the process until reaching the desired y sweep distance
  // You may need to adjust this condition based on your specific requirements
  if (yPos < Y_SWEEP_DISTANCE) {
    // Reset stepperX position for next sweep
    stepperX.setCurrentPosition(0);
  }

    
}

float readUltrasonicSensor() {
  // Trigger the ultrasonic sensor
  digitalWrite(TRIGGER_PIN, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIGGER_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIGGER_PIN, LOW);

  // Measure the duration of the echo pulse
  unsigned long duration = pulseIn(ECHO_PIN, HIGH);

  // Convert the duration to distance (in centimeters)
  float distance = duration * 0.034 / 2;

  return distance;


}

</code></pre>

This code is kind of a Frankenstein of a lot of other people's questions, suggestions, and my own attempts. I'm not a super strong coder, but I figured this would be enough to give me a working start when I got back to Cambridge. 

Ultimately it was a good jumping off point, but figuring out the circuitry to run two stepper motors addimitedly took me a pretty long time. There were some issues where I had to solder a new 12V power supply because the one I had was not working, and even then it took me a while to figure out how to use the stepper motor drivers (I used 2 A4988's).

But eventually I was able to get one of the motors running, and then adding one more to the circuit wasn't too hard.

<p class="margin">   </p>
<div class="flexrow">
  <video controls>
    <source src="mvp_turning.mov" type="video/mp4">
  </video>
  </div>
<p class="caption">It works kinda!!
</p>

Once I was able to get the motors attached to the circuit, I added the sensor and at this point I was pretty sure it was working. When I would run the code, I'd hear the little clicking from the sensor which told me it was recording data, and then I would also see the X direction motor do a full distance sweep (I set it to be 10 steps for the sake of checking that it was working) and then every 10th step by the X motor, the Y motor would do one step. Then the X motor would go back the otherway another 10 steps and the process would repeat. So it seemed like things were doing what I wanted. 

Next I added some code to create arrays of the position and z distance... I'm not sure if arrays were the best way to do this, but coming from my limited knowledge of coding, it seemed like an ok try


<pre><code style="background-color: #2d2b33;">
 
#include <AccelStepper.h>

// Define the number of steps per revolution for each motor
#define STEPS_PER_REV 200

// Define the pins connected to the stepper motor drivers
#define X_STEP_PIN 13
#define X_DIR_PIN 12
#define Y_STEP_PIN 4
#define Y_DIR_PIN 5

// Define the distance to move along each axis for one sweep
#define X_SWEEP_DISTANCE 200
#define Y_SWEEP_DISTANCE 1  

// Define initial position
#define INITIAL_X_POS 0
#define INITIAL_Y_POS 0

// Define ultrasonic sensor pins
#define TRIGGER_PIN 6
#define ECHO_PIN 7

// Initialize the stepper motors
AccelStepper stepperX(AccelStepper::DRIVER, X_STEP_PIN, X_DIR_PIN);
AccelStepper stepperY(AccelStepper::DRIVER, Y_STEP_PIN, Y_DIR_PIN);

// Initialize position variables
int xPos = INITIAL_X_POS;
int yPos = INITIAL_Y_POS;

// Define arrays to store coordinates
#define MAX_COORDINATES 100 // Adjust as needed
float xCoordinates[MAX_COORDINATES];
float yCoordinates[MAX_COORDINATES];
float zDistances[MAX_COORDINATES];
int currentIndex = 0;

void setup() {
  // Set up the ultrasonic sensor pins
  pinMode(TRIGGER_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);
  
  Serial.begin(9600);

  // Set the maximum speed and acceleration for each motor
  stepperX.setMaxSpeed(100); // Adjust as needed
  stepperX.setAcceleration(100); // Adjust as needed
  stepperY.setMaxSpeed(100); // Adjust as needed
  stepperY.setAcceleration(100); // Adjust as needed
}

void loop() {

  // Sweep along the x-axis
  stepperX.moveTo(X_SWEEP_DISTANCE);
  while (stepperX.distanceToGo() != 0) {
    stepperX.run();
    xPos++;
    // Read data from the ultrasonic sensor
    float distanceZ = readUltrasonicSensor();
    // Store the coordinates and distance
    xCoordinates[currentIndex] = xPos;
    yCoordinates[currentIndex] = yPos;
    zDistances[currentIndex] = distanceZ;
    currentIndex++;
  }

  // Move down a small increment in the y direction
  stepperY.move(Y_SWEEP_DISTANCE);
  stepperY.runToPosition();
  yPos++;

  // Sweep along the x-axis in the opposite direction
  stepperX.moveTo(0);
  while (stepperX.distanceToGo() != 0) {
    stepperX.run();
    xPos--;
    // Read data from the ultrasonic sensor
    float distanceZ = readUltrasonicSensor();
    // Store the coordinates and distance
    xCoordinates[currentIndex] = xPos;
    yCoordinates[currentIndex] = yPos;
    zDistances[currentIndex] = distanceZ;
    currentIndex++;
  }

  // Move down another increment in the y direction
  stepperY.move(Y_SWEEP_DISTANCE);
  stepperY.runToPosition();
  yPos++;



  // Repeat the process until reaching the desired y sweep distance
  // You may need to adjust this condition based on your specific requirements
  if (yPos < Y_SWEEP_DISTANCE) {
    // Reset stepperX position for next sweep
    stepperX.setCurrentPosition(0);
  }

    
}

float readUltrasonicSensor() {
  // Trigger the ultrasonic sensor
  digitalWrite(TRIGGER_PIN, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIGGER_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIGGER_PIN, LOW);

  // Measure the duration of the echo pulse
  unsigned long duration = pulseIn(ECHO_PIN, HIGH);

  // Convert the duration to distance (in centimeters)
  float distance = duration * 0.034 / 2;

  return distance;


}

</code></pre>

Now I'm pretty sure the machine was recording where the sensor would be as well as the data it would be picking up.. The problem was I wasn't sure how to actually view the arrays... I tried a lot of things here. The most promising method (after consulting with Bobby and the internet) was to serial print the arrays using a for loop over each array. I already had a variable "currentIndex" defined which should have been the lenght of the three arrays at any given time, so I used that to write a little code that I added:

<pre><code style="background-color: #2d2b33;">

  #include <AccelStepper.h>

// Define the number of steps per revolution for each motor
#define STEPS_PER_REV 200

// Define the pins connected to the stepper motor drivers
#define X_STEP_PIN 13
#define X_DIR_PIN 12
#define Y_STEP_PIN 4
#define Y_DIR_PIN 5

// Define the distance to move along each axis for one sweep
#define X_SWEEP_DISTANCE 200
#define Y_SWEEP_DISTANCE 1  

// Define initial position
#define INITIAL_X_POS 0
#define INITIAL_Y_POS 0

// Define ultrasonic sensor pins
#define TRIGGER_PIN 6
#define ECHO_PIN 7

// Initialize the stepper motors
AccelStepper stepperX(AccelStepper::DRIVER, X_STEP_PIN, X_DIR_PIN);
AccelStepper stepperY(AccelStepper::DRIVER, Y_STEP_PIN, Y_DIR_PIN);

// Initialize position variables
int xPos = INITIAL_X_POS;
int yPos = INITIAL_Y_POS;

// Define arrays to store coordinates
#define MAX_COORDINATES 100 // Adjust as needed
float xCoordinates[MAX_COORDINATES];
float yCoordinates[MAX_COORDINATES];
float zDistances[MAX_COORDINATES];
int currentIndex = 0;

void setup() {
  // Set up the ultrasonic sensor pins
  pinMode(TRIGGER_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);
  
  Serial.begin(9600);

  // Set the maximum speed and acceleration for each motor
  stepperX.setMaxSpeed(100); // Adjust as needed
  stepperX.setAcceleration(100); // Adjust as needed
  stepperY.setMaxSpeed(100); // Adjust as needed
  stepperY.setAcceleration(100); // Adjust as needed
}

void loop() {

  // Sweep along the x-axis
  stepperX.moveTo(X_SWEEP_DISTANCE);
  while (stepperX.distanceToGo() != 0) {
    stepperX.run();
    xPos++;
    // Read data from the ultrasonic sensor
    float distanceZ = readUltrasonicSensor();
    // Store the coordinates and distance
    xCoordinates[currentIndex] = xPos;
    yCoordinates[currentIndex] = yPos;
    zDistances[currentIndex] = distanceZ;
    currentIndex++;
  }

  // Move down a small increment in the y direction
  stepperY.move(Y_SWEEP_DISTANCE);
  stepperY.runToPosition();
  yPos++;

  // Sweep along the x-axis in the opposite direction
  stepperX.moveTo(0);
  while (stepperX.distanceToGo() != 0) {
    stepperX.run();
    xPos--;
    // Read data from the ultrasonic sensor
    float distanceZ = readUltrasonicSensor();
    // Store the coordinates and distance
    xCoordinates[currentIndex] = xPos;
    yCoordinates[currentIndex] = yPos;
    zDistances[currentIndex] = distanceZ;
    currentIndex++;
  }

  // Move down another increment in the y direction
  stepperY.move(Y_SWEEP_DISTANCE);
  stepperY.runToPosition();
  yPos++;


for (int i = 0; i < 10 ; i++) {
  Serial.print(xCoordinates[i]);
  Serial.print(",");
  Serial.print(yCoordinates[i]);
  Serial.print(",");
  Serial.print(zDistances[i]);
  Serial.print("\n"); // Tab character to separate data points
}
  
Serial.println(); // Newline to mark the end of the batch

  // Repeat the process until reaching the desired y sweep distance
  // You may need to adjust this condition based on your specific requirements
  if (yPos < Y_SWEEP_DISTANCE) {
    // Reset stepperX position for next sweep
    stepperX.setCurrentPosition(0);
  }

    
}

float readUltrasonicSensor() {
  // Trigger the ultrasonic sensor
  digitalWrite(TRIGGER_PIN, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIGGER_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIGGER_PIN, LOW);

  // Measure the duration of the echo pulse
  unsigned long duration = pulseIn(ECHO_PIN, HIGH);

  // Convert the duration to distance (in centimeters)
  float distance = duration * 0.034 / 2;

  return distance;

</code></pre>

But the problem I am currently facing is that I think the amount of memory reading out these arrays takes is just... way to much. I can get the serial monitor to show other things like "Hello World." But I think maybe I might just be asking it to print too many things all at once and so it's getting overwhelmed and angry at me. I'm actually pretty confident that I'm creating the arrays I want to make with this code, but accessing them is kind of the hard part from here. 

At first, when I tried to run the code, it wouldn't do it at all because it said that just taking all of those points of data was using too much memory. I streamlined things a bit along the way to the point where now it will run the code and the motors will move and the sensor will come on without a hitch, it just really doesn't want to print what I ask it too. 


<p class="margin">   </p>
<div class="flexrow">
  <img src="circuitry_1.jpeg" alt="an Arduino circuit with a 2 stepper motors">
  <img src="circuitry_1.jpeg" alt="another shot">
</div>
<p class="caption">Picture of the circuitry.</p>

</div>
</xmp>
</body>

<script src="../strapdown.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" ></script>

</html>